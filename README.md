# 방문자 수 트래킹 API

### 목차
1. [프로젝트 개요](###프로젝트-개요)
2. [이런 점을 고민했어요!](###이런-점을-고민했어요!)
3. [이런 문제를 해결했어요!](###이런-문제를-해결했어요!)
4. [이런 점을 보완하려고 해요!](###이런-점을-보완하려고-해요!)

<br/>

### 프로젝트 개요
---
방문자 수를 트래킹하는 간단한 서비스를 구현하였습니다.

#### API 목록
- url 정보를 저장하는 API
- 호출 시 url의 카운트를 증가하는 API
- 일간/누적 방문자 수를 조회하는 API
- 사용자가 설정한 기간의 방문자 수를 조회하는 API

#### 개발 환경 및 기술 스택
Java, Spring Boot, Gradle, JPA, MySQL, Swagger

#### ERD
![image](https://github.com/Sesolj/visitorTracking/assets/147023239/59999f25-db0a-4c56-8d14-ab541ed20324)

특정 날짜/기간의 방문자 수를 조회하기 위해 일자와 방문자 수를 저장하는 로그 테이블을 따로 생성하였습니다.

스케줄링 코드를 통해 매일 자정 각 url의 일자 별 방문자 수를 로그 테이블에 저장합니다.

최대 조회 가능 일자는 7일이며, 그 이상의 데이터는 최근 데이터로 UPDATE하도록 구현하였습니다.

<br/>

### 이런 점을 고민했어요!
---
#### Builder 패턴
처음 Java 학습 시에는 주로 Getter, Setter를 통해 데이터에 접근했습니다. 하지만 Entity Class에서 Setter를 사용하면 객체일관성을 해칠 수 있다는 것을 배우게 되었고, 이후 생성자를 통해 데이터에 값을 주입하고 있습니다. 해당 프로젝트 역시 객체일관성을 유지하고 객체 생성 시 명시적으로 필드를 선언함으로써 가독성을 높이는 Builder 패턴에 따라 코드를 작성하였습니다.

#### 날짜 관련 정보의 처리 방식 통일
코드의 일관성을 해치는 여러 요인 중 하나는 바로 날짜와 관련된 정보라고 생각합니다. 재직 당시 개발자에 따라 구현 방식이 달라, 데이터를 String으로 받아 형변환 하는 방법, 처음부터 DateTime 형으로 받는 방법이 코드에 혼재되어 있었기 때문입니다.

이를 계기로 날짜 관련 정보에 대한 처리 방식을 고려하게 되었고, 불필요한 형변환 과정을 줄이기 위해 String이 아닌 LocalDateTime 형으로 데이터를 받을 수 있게 했습니다. 이를 위해 DTO에 ```@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")``` 어노테이션을 추가하여 데이터를 직렬화하고, Swagger 사용자의 편의를 위해 ```@Schema``` 어노테이션으로 원하는 날짜 포맷을 hint로써 표기했습니다.

#### 테스트 격리
@Transactional이 내장되어 있는 @DataJpaTest 어노테이션을 통해 테스트용 데이터를 롤백하는 방식으로 테스트를 수행하였습니다.

개발 초기에는 @SpringBootTest를 사용했으나 ```@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)```와 같이 환경을 설정할 경우 별도의 Thread에서 스프링 컨테이너가 실행되어 롤백이 되지 않는 문제가 발생하였습니다.

따라서 이 경우에는 데이터를 전부 삭제시키는 방법으로 DB를 초기화해야 된다는 것을 알게 되었습니다. 이로 인해 별도의 테스트용 DB를 생성해야된다는 점, 또한 모든 Bean을 로드하는 @SpringBootTest의 특성이 가벼운 프로그램에는 맞지 않는다고 생각하여 생산성을 위해 테스트 격리 방식을 변경하였습니다.

#### @ControllerDevice와 커스텀 Enum을 통한 예외 처리
비즈니스 로직 예외 처리를 위해 개발자가 thorw할 수 있는 예외 처리 방식을 구현하였습니다.

예외 발생 시 반환할 Http Status와 메세지를 관리하기 위해 커스텀 Exception Enum과 RuntimeException을 상속받는 Custom Exception을 생성하고, @ControllerAdvice 어노테이션을 통해 다양한 예외를 일관적인 방식으로 처리할 수 있도록 코드를 작성하였습니다.
```
Exception 관리를 위한 별도의 패키지
├── exception
│   ├── ApiException
│   ├── ApiExceptionEntity
│   ├── ApiExceptionHandler
│   └── ExceptionEnum
├──
```

<br/>

### 이런 문제를 해결했어요!
---
#### 테스트 데이터가 롤백되지 않는 문제(Database 엔진 문제)
@DataJpaTest에 @Transactional이 내장되어 있음에도, 테스트 코드 실행 종료 후에 데이터가 롤백되지 않는 문제가 있었습니다. 특별한 Exception 발생 없이 로그상에는 RollBack이 되었다고 출력되어, 해결에 난항을 겪었습니다.

원인은 데이터베이스의 엔진이었습니다. 데이터베이스가 트랜잭션을 지원하지 않는 MyISAM 엔진으로 생성되어 있었기 때문이었습니다. ```ALTER TABLE {테이블명} ENGINE = INNODB``` 명령을 통해 엔진을 InnoDB로 변경하여 해결하였습니다. 이를 계기로 데이터베이스 엔진의 여러 종류, 그리고 트랜잭션 지원 여부와 같은 각 엔진의 특성을 학습할 수 있었습니다.

#### Bulk Update 테스트 시 값 검증 오류 문제
모든 레코드의 값을 한꺼번에 변경하는 Bulk update 기능 구현 후 테스트 코드에서 값 변경이 적용되지 않아 계속 테스트가 실패하는 문제가 있었습니다.

원인은 영속성 컨텍스트 때문이었습니다. 단일 update와 다르게 일괄 update 시에는 영속성 컨텍스트를 통해 Entity를 관리하지 못한다는 것을 알게 되었습니다. 따라서 별도로 ```EntityManager```를 주입받은 후 ```flush()```와 ```clear()```를 통해 데이터 반영 후 영속성 컨텍스트를 비우고 다시 조회하는 방법으로 문제를 해결하였습니다. 이를 계기로 JPA의 영속성 컨텍스트 개념과 특징에 대해 배우게 되었습니다.

#### @PathVariable 404 Request Error(스프링 시큐리티의 정규화로 인한 문제)
#### DTO Java Beans 규약 문제

<br/>

### 이런 점을 보완하려고 해요!
---
